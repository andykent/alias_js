<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

  <title>index</title>

  <script src="alias.js" type="text/javascript" charset="utf-8"></script>
  <script type="text/javascript" charset="utf-8">




  // Time delays, scoping and chained dispatch are all fully supported.
  
  var d = {
    a: function() { console.log('hello from a') },
    b: function(func, msg) { console.log(msg+' - was sent from '+func+' via b') }
  };

  alias('a', 'b')
    .withSourceScope(d)
    .as('c', 'd', 'e')
    .withNamedCaller()
    .delayBy(1000);

  c('hello from c');




  // You can build multi-step function chains and even define the chain before defining the source function, great for meta-programming.
  
  alias('demo').as('demo1');
  alias('demo1').as('demo2');
  alias('demo2').as('demo3');

  function demo() { console.log('hello from demo') };

  demo3();
  
  
  
  
  // As aliases are evaluated on the fly you can define new ones at runtime. 
  // This is a very contrived example but in practice it can be useful for defering and/or caching conditional logic.
  
  function login(password) {
    if(password=='secrets')
      alias('authenticated').as('login');
    else
      alias('blocked').as('login');
    return login(password);
  };
  function authenticated(password) { console.log('Password "'+password+'" accepted, user is logged in'); return true; };
  function blocked(password) { console.log('Password "'+password+'" invalid, user is blocked'); return false };
  
  login('secrets');
  
  
  
  
  // filters allow for wrapping additional functionality around existing functions
  // they can be handy for modifing external libraries
  
  myLib = { demo: function() { console.log('hello from my filtered library') } };
  function myBeforeFilter() { console.log("I'm a before filter") };  
  function myHaltingBeforeFilter() { console.log("I halted the filter chain"); throw('halt') };  
  alias('demo')
    .withScope(myLib)
    .beforeEach(myBeforeFilter)
    .as('demo');
  
  alias('demo')
    .withScope(myLib)
    .beforeAll(myHaltingBeforeFilter)
    .as('demo2');
  
  myLib.demo();
  myLib.demo2();
  
  alias('demo')
    .withScope(myLib)
    .beforeEach(myBeforeFilter)
    .as('demo');
  
  myLib.demo();
  
  
  
  // filters can even modify the arguments that are being passed in by returning an array. 
  // if you don't wish to modify the arguments then simply don't return anything.
  
  function base(a, b) { console.log('Base received a='+a+' b='+b) };
  function modifyFilter(a, b) { return [a+1, b*10] };
  var rd = alias('base')
    .beforeEach(modifyFilter)
    .as('base');
    
  base(1, 5);
  
  rd.revert();
  
  base(1, 5);
   
  </script>

</head>

<body>


</body>
</html>
